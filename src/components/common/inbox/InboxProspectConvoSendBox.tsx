import moment from "moment";
import {
  openedProspectIdState,
  openedBumpFameworksState,
  selectedBumpFrameworkState,
  currentConvoLiMessageState,
  currentConvoChannelState,
  currentConvoEmailMessageState,
  fetchingProspectIdState,
  tempHiddenProspectsState,
  selectedEmailSequenceStepState,
  selectedEmailThread,
  bumpFrameworkSelectedSubstatusState,
  selectedEmailReplyFrameworkState,
} from "@atoms/inboxAtoms";
import { userDataState, userTokenState } from "@atoms/userAtoms";
import { openConfirmModal } from "@mantine/modals";
import {
  Badge,
  Paper,
  Flex,
  Textarea,
  Text,
  Button,
  useMantineTheme,
  Group,
  ActionIcon,
  LoadingOverlay,
  Tooltip,
  Select,
  Box,
  Popover,
  Indicator,
  MultiSelect,
  Divider,
  Radio,
  Avatar,
} from "@mantine/core";
import { getHotkeyHandler } from "@mantine/hooks";
import { hideNotification, showNotification } from "@mantine/notifications";
import {
  IconExternalLink,
  IconWriting,
  IconSend,
  IconChevronUp,
  IconChevronDown,
  IconSettings,
  IconArrowsDiagonalMinimize2,
  IconClock,
  IconArrowUp,
  IconCalendar,
  IconZzz,
  IconHourglass,
  IconX,
  IconPencil,
  IconTags,
  IconEdit,
  IconAdjustmentsHorizontal,
  IconArrowsMoveVertical,
  IconCopy,
} from "@tabler/icons";
import {
  IconClock24,
  IconMessage2Cog,
  IconSettingsFilled,
  IconWand,
  IconMessageDots,
  IconSparkles,
  IconCalendarDollar,
} from "@tabler/icons-react";
import { useQueryClient } from "@tanstack/react-query";
import { deleteAutoBumpMessage } from "@utils/requests/autoBumpMessage";
import { sendLinkedInMessage } from "@utils/requests/sendMessage";
import _, { debounce, get, set } from "lodash";
import {
  forwardRef,
  useCallback,
  useEffect,
  useImperativeHandle,
  useMemo,
  useRef,
  useState,
} from "react";
import { useRecoilState, useRecoilValue } from "recoil";
import {
  BumpFramework,
  EmailReplyFramework,
  EmailSequenceStep,
  EmailThread,
  LinkedInMessage,
  Prospect,
} from "src";
import {
  generateAIEmailReply,
  generateAIFollowup,
} from "./InboxProspectConvoBumpFramework";
import AutoBumpFrameworkInfo from "@common/prospectDetails/AutoBumpFrameworkInfo";
import { ratio as fuzzratio } from "fuzzball";
import { sendEmail } from "@utils/requests/sendEmail";
import RichTextArea from "@common/library/RichTextArea";
import TextAreaWithAI from "@common/library/TextAreaWithAI";
import { JSONContent } from "@tiptap/react";
import DOMPurify from "dompurify";
import { postGenerateFollowupEmail } from "@utils/requests/emailMessageGeneration";
import { API_URL } from "@constants/data";
import { Calendar, DateTimePicker, TimeInput } from "@mantine/dates";
import { updateChannelStatus } from "@common/prospectDetails/ProspectDetailsChangeStatus";
import postSmartleadReply from "@utils/requests/postSmartleadReply";
import { convertToTitleCase } from "@utils/stringFormatting";
import { postGenerateEmailReplyUsingFramework } from "@utils/requests/emailReplies";
import { getBumpFrameworks } from "@utils/requests/getBumpFrameworks";
import {ScheduledMessage} from "./ScheduledMessage";

export default forwardRef(function InboxProspectConvoSendBox(
  props: {
    prospectId: number;
    linkedin_public_id: string;
    email: string;
    nylasMessageId?: string;
    scrollToBottom?: () => void;
    msgLoading?: boolean;
    minimizedSendBox: () => void;
    currentSubstatus?: string;
    triggerGetSmartleadProspectConvo?: () => void;
    archetypeId?: number;
  },
  ref
) {
  useImperativeHandle(
    ref,
    () => {
      return {
        getAiGenerated: () => aiGenerated,
        setAiGenerated: setAiGenerated,
        getMessageDraft: () => messageDraft,
        setMessageDraft: (
          msg: string,
          bumpFramework?: {
            description?: string;
            id?: number;
            length?: string;
            title?: string;
          },
          accountResearch?: string[]
        ) => {
          // bumpFramework is no longer used because we want to show default bump framework and NOT the autogenerated one
          setMessageDraft(msg);
          if (accountResearch) {
            setBumpFramework((prev) => {
              if (!prev) {
                return prev;
              }
              return {
                ...prev,
                account_research: accountResearch,
              };
            });
          }
        },
        setAiMessage: (msg: string) => {
          setAiMessage(msg);
        },
        setBumpFrameworks: (bumpFrameworks: BumpFramework[]) => {
          setBumpFrameworks(bumpFrameworks);

          // Set the default bump framework
          // if (!selectedBumpFramework?.id) {
          //   if (bumpFrameworks.length > 0) {
          //     setBumpFramework(bumpFrameworks[0]);
          //     for (let i = 0; i < bumpFrameworks.length; i++) {
          //       if (bumpFrameworks[i].default) {
          //         setBumpFramework(bumpFrameworks[i]);
          //         break;
          //       }
          //     }
          //   }
          // }
        },
        setEmailReplyFrameworks: (
          emailReplyFrameworks: EmailReplyFramework[]
        ) => {
          // Only set the sequence step to the selected substatus
          setEmailReplyFrameworks(emailReplyFrameworks);
          // Set the default bump framework
          // if (emailReplyFrameworks.length > 0) {
          //   setEmailSequenceStep(emailReplyFrameworks[0]);
          //   for (let i = 0; i < emailReplyFrameworks.length; i++) {
          //     if (emailReplyFrameworks[i].default) {
          //       setEmailSequenceStep(emailReplyFrameworks[i]);
          //       break;
          //     }
          //   }
          // }
        },
      };
    },
    []
  );

  const theme = useMantineTheme();
  const queryClient = useQueryClient();
  const userToken = useRecoilValue(userTokenState);
  const userData = useRecoilValue(userDataState);
  const [scheduleDay, setScheduleDay] = useState<Date | undefined>(undefined);
  const [showSchedulePopup, setShowSchedulePopup] = useState(false);
  const [snoozeDay, setSnoozeDay] = useState(
    moment(new Date()).add(4, "days").toDate()
  );
  const openedProspectId = useRecoilValue(openedProspectIdState);
  const scheduledMessageRef = useRef(null);
  const openedOutboundChannel = useRecoilValue(currentConvoChannelState);
  const [fetchingProspectId, setFetchingProspectId] = useRecoilState(
    fetchingProspectIdState
  );
  const [showCalendarPopup, setShowCalendarPopup] = useState(false);
  const [openBumpFrameworks, setOpenBumpFrameworks] = useRecoilState(
    openedBumpFameworksState
  );
const [sdrSchedulingLinks, setSdrSchedulingLinks] = useState<{ label: string; value: string }[]>([
]);
  const [
    setOpenBumpFrameworksSubstatus,
    setSetOpenBumpFrameworksSubstatus,
  ] = useRecoilState(bumpFrameworkSelectedSubstatusState);
  const [selectedBumpFramework, setBumpFramework] = useRecoilState(
    selectedBumpFrameworkState
  ); // LinkedIn
  const [selectedEmailReplyFramework, setEmailReplyFramework] = useRecoilState(
    selectedEmailReplyFrameworkState
  ); // Email
  const [currentConvoLiMessages, setCurrentConvoLiMessages] = useRecoilState(
    currentConvoLiMessageState
  );
  const [
    currentConvoEmailMessages,
    setCurrentConvoEmailMessages,
  ] = useRecoilState(currentConvoEmailMessageState);
  const [currentConvoEmailThread, setCurrentConvoEmailThread] = useRecoilState(
    selectedEmailThread
  );

  const [tempHiddenProspects, setTempHiddenProspects] = useRecoilState(
    tempHiddenProspectsState
  );

  const [bumpFrameworks, setBumpFrameworks] = useState<BumpFramework[]>([]);
  const [emailReplyFrameworks, setEmailReplyFrameworks] = useState<
    EmailReplyFramework[]
  >([]);
  const isValidEmail = (email: string) => {
    return /\S+@\S+\.\S+/.test(email);
  };
  const [replyLabel, setReplyLabel] = useState(props.currentSubstatus);
  // We use this to store the value of the text area
  const [messageDraft, _setMessageDraft] = useState("");
  // We use this to store the raw value of the rich text editor
  const messageDraftRichRaw = useRef<JSONContent | string>();

  // We use this to set the value of the text area (for both rich text and normal text)
  const setMessageDraft = (value: string) => {
    messageDraftRichRaw.current = value;
    _setMessageDraft(value);
  };
  // For email we have to use this ref instead, otherwise the textbox does a weird refocusing.
  const messageDraftEmail = useRef("");

  const [aiMessage, setAiMessage] = useState("");
  const [aiGenerated, setAiGenerated] = useState(false);
  const [msgLoading, setMsgLoading] = useState(props.msgLoading || false);

  const [ccEmails, setCcEmails] = useState<string[]>([]);
  const [bccEmails, setBccEmails] = useState<string[]>([]);

  const [ccInputValue, setCcInputValue] = useState("");
  const [bccInputValue, setBccInputValue] = useState("");

  const [showCc, setShowCc] = useState<boolean>(false);
  const [showBcc, setShowBcc] = useState<boolean>(false);

  const sendMessage = async () => {
    setMsgLoading(true);

    // Delete the auto bump message if it exists
    await deleteAutoBumpMessage(userToken, props.prospectId);

    // Hack to update the prospect list to temp show they're in purgatory
    setTempHiddenProspects(tempHiddenProspects.concat([props.prospectId]));

    if (openedOutboundChannel === "LINKEDIN") {
      const msg = messageDraft;
      setMessageDraft("");
      showNotification({
        id: "send-linkedin-message",
        title: scheduleDay ? "Scheduling message..." : "Sending message ...",
        message: "Message is sending. Do not refresh the page.",
        color: "blue",
        autoClose: 7000,
      });
      setTimeout(() => setFetchingProspectId(-1), 15000);

      setFetchingProspectId(openedProspectId);
      sendLinkedInMessage(
        userToken,
        props.prospectId,
        msg,
        aiGenerated,
        undefined,
        selectedBumpFramework?.id,
        selectedBumpFramework?.title,
        selectedBumpFramework?.description,
        selectedBumpFramework?.bump_length,
        selectedBumpFramework?.account_research,
        snoozeDay,
        scheduleDay
      ).then(() => {
        queryClient.refetchQueries({
          queryKey: [`query-get-dashboard-prospect-${openedProspectId}-convo-${openedOutboundChannel}`],
        });
      });
      if (true) {
        let yourMessage = _.cloneDeep(currentConvoLiMessages || [])
          .reverse()
          .find((msg) => msg.connection_degree === "You");
        if (yourMessage) {
          yourMessage.message = msg;
          yourMessage.date = new Date().toUTCString();
          yourMessage.ai_generated = false;
          yourMessage.is_sending = true;
          setCurrentConvoLiMessages([
            ...(currentConvoLiMessages || []),
            yourMessage,
          ]);
        } else {
          queryClient.refetchQueries({
            queryKey: [`query-get-dashboard-prospect-${openedProspectId}-convo-${openedOutboundChannel}`],
          });
          queryClient.refetchQueries({
            queryKey: ["query-prospects-list"],
          });
        }
        // showNotification({
        //   id: "send-linkedin-message-complete",
        //   title: scheduleDay ? "Message Scheduled" : "Message Sent",
        //   message: "",
        //   color: "green",
        // });
      } else {
        showNotification({
          id: "send-linkedin-message-error",
          title: "Error",
          message: "Failed to send message. Please try again later.",
          color: "red",
          autoClose: false,
        });
      }
    } else if (openedOutboundChannel === "SMARTLEAD") {
      const prospectid = props.prospectId;
      const response = await postSmartleadReply(
        userToken,
        prospectid,
        messageDraftEmail.current,
        scheduleDay,
        ccEmails,
        bccEmails
      );
      if (response.status !== "success") {
        showNotification({
          title: "Error",
          message: "Failed to send email",
          color: "red",
        });
      } else {
        //clear the input values
        setCcEmails([]);
        setBccEmails([]);
        setCcInputValue("");
        setBccInputValue("");
        setMessageDraft("");
        //close the email composer dialog
        props.minimizedSendBox();
        if (scheduleDay) {
          showNotification({
            title: "Success",
            message: "Email scheduled to send.",
            color: "green",
          });
        } else {
          showNotification({
            title: "Success",
            message:
              "Email sent. It may take a few minutes to appear in your inbox.",
            color: "green",
          });
        }

        setMessageDraft("");
      }
      if (props?.triggerGetSmartleadProspectConvo) {
        props?.triggerGetSmartleadProspectConvo();
      }
      setScheduleDay(undefined);
    } else {
      if (
        currentConvoEmailMessages === undefined ||
        currentConvoEmailMessages.length === 0
      ) {
        showNotification({
          id: "send-email-message-error",
          title: "Error",
          message: "Please select an email thread",
          color: "red",
          autoClose: false,
        });
        setMsgLoading(false);
        return;
      }
      const msg = messageDraftEmail.current;
      if (msg.length === 0) {
        showNotification({
          id: "send-email-message-error",
          title: "Error",
          message: "Please enter a message",
          color: "red",
          autoClose: false,
        });
        setMsgLoading(false);
        return;
      }

      // Get the last message
      const replyToMessageID =
        currentConvoEmailMessages[currentConvoEmailMessages.length - 1]
          .nylas_message_id;
      const result = await sendEmail(
        userToken,
        props.prospectId,
        `Re: ${currentConvoEmailThread?.subject}`,
        msg,
        aiGenerated,
        replyToMessageID
      );
      if (result.status === "success") {
        let yourMessage = _.cloneDeep(currentConvoEmailMessages || [])
          .reverse()
          .find((msg) => msg.from_sdr);
        if (yourMessage) {
          yourMessage.body = msg;
          yourMessage.date_received = new Date().toUTCString();
          yourMessage.ai_generated = false;
          setCurrentConvoEmailMessages([
            ...(currentConvoEmailMessages || []),
            yourMessage,
          ]);
        } else {
          queryClient.refetchQueries({
            queryKey: [`query-get-dashboard-prospect-${openedProspectId}-convo-${openedOutboundChannel}`],
          });
        }
        messageDraftEmail.current = "";
        messageDraftRichRaw.current = "";
        setMessageDraft("");
      } else {
        showNotification({
          id: "send-email-message-error",
          title: "Error",
          message: "Failed to send message. Please try again later.",
          color: "red",
          autoClose: false,
        });
      }
    }

    setTimeout(() => {
      if (scheduledMessageRef.current) {
        (scheduledMessageRef.current as any).refreshScheduledMessages();
      }
    }, 200);

    setMsgLoading(false);
    setAiGenerated(false);
    setTimeout(() => props.scrollToBottom && props.scrollToBottom(), 100);
  };

  // If messageDraft is cleared, odds are that the AI generated message was cleared, and the new message is likely not to be AI generated
  useEffect(() => {
    checkFuzz(messageDraft, aiMessage);
  }, [messageDraft, aiMessage]);

  const checkFuzz = useCallback(
    debounce((message, aiMessage) => {
      const ratio = fuzzratio(message, aiMessage);
      // ratio > 5 && setAiGenerated(true);
      // ratio <= 5 && setAiGenerated(false);
      setAiGenerated(true);
    }, 200),
    []
  );

  useEffect(() => {
    get_all_sdr_scheduling_links();

    (async () => {
      const result = await getBumpFrameworks(
        userToken,
        ["ACTIVE_CONVO"],
        [],
        [],
        undefined,
        undefined,
        undefined,
        undefined,
        props.archetypeId
      );

      let bumpFrameworkArray = [] as BumpFramework[];
      for (const bumpFramework of result.data
        .bump_frameworks as BumpFramework[]) {
        if (bumpFramework.default) {
          bumpFrameworkArray.unshift(bumpFramework);
        } else {
          bumpFrameworkArray.push(bumpFramework);
        }
      }

      setBumpFrameworks(bumpFrameworkArray);
      setBumpFramework(
        bumpFrameworkArray.length > 0 ? bumpFrameworkArray[0] : undefined
      );
    })();
  }, [props.prospectId, props.archetypeId, replyLabel]);

  const get_all_sdr_scheduling_links = async () => {
    try {
      const response = await fetch(
        `${API_URL}/client/sdr/scheduling_links`,
        {
          method: "GET",
          headers: {
            "Content-Type": "application/json",
            Authorization: `Bearer ${userToken}`,
          },
        }
      );

      const result = await response.json();

      if (response) {
        setSdrSchedulingLinks(result.data);
        console.log('setting links to', result.data);
      } else {
        setSdrSchedulingLinks([]);
      }
    } catch (error) {
      setSdrSchedulingLinks([]);
    }
  }

  const smartGenerate = async (additional_instructions: string) => {
    setMsgLoading(true);
    if (openedOutboundChannel === "LINKEDIN") {
      const result = fetch(
        `${API_URL}/li_conversation/prospect/generate_smart_response`,
        {
          method: "POST",
          headers: {
            "Content-Type": "application/json",
            Authorization: `Bearer ${userToken}`,
          },
          body: JSON.stringify({
            prospect_id: props.prospectId,
            additional_instructions: additional_instructions,
          }),
        }
      )
        .then((res) => res.json())
        .then((j) => {
          const message = j["message"];

          setMessageDraft(message);
          setAiMessage(message);
          setBumpFramework(j["bump_framework"]);
          setAiGenerated(true);

          showNotification({
            id: "generate-linkedin-message",
            title: "Generated message",
            message: "",
            color: "green",
            autoClose: 3000,
          });
        })
        .catch((e) => {
          showNotification({
            id: "generate-linkedin-message-error",
            title: "Error",
            message: "Failed to generate message",
            color: "red",
            autoClose: 3000,
          });
        })
        .finally(() => {
          setMsgLoading(false);
        });
    }
  };

  useEffect(() => {
    if (replyLabel !== props.currentSubstatus) {
      setReplyLabel(props.currentSubstatus);
    }
  }, [props.currentSubstatus]);

  const replyLabels = useMemo(() => {
    const labels = [
      "ACTIVE_CONVO_QUESTION",
      "ACTIVE_CONVO_QUAL_NEEDED",
      "ACTIVE_CONVO_OBJECTION",
      "ACTIVE_CONVO_SCHEDULING",
      "ACTIVE_CONVO_NEXT_STEPS",
      "ACTIVE_CONVO_REVIVAL",
      "ACTIVE_CONVO_CIRCLE_BACK",
      "ACTIVE_CONVO_REFERRAL",
      "ACTIVE_CONVO_QUEUED_FOR_SNOOZE",
      "ACTIVE_CONVO_CONTINUE_SEQUENCE",
      "ACTIVE_CONVO_BREAKUP",
    ];

    return Array.from(labels);
  }, [bumpFrameworks]);

  const labelEmoji = (label: string) => {
    switch (label) {
      case "ACTIVE_CONVO_QUESTION":
        return "❓";
      case "ACTIVE_CONVO_QUAL_NEEDED":
        return "👍";
      case "ACTIVE_CONVO_OBJECTION":
        return "👆";
      case "ACTIVE_CONVO_SCHEDULING":
        return "📆";
      case "ACTIVE_CONVO_NEXT_STEPS":
        return "➡️";
      case "ACTIVE_CONVO_REVIVAL":
        return "🏥";
      case "ACTIVE_CONVO_CIRCLE_BACK":
        return "🔄";
      case "ACTIVE_CONVO_REFERRAL":
        return "👥";
      case "ACTIVE_CONVO_QUEUED_FOR_SNOOZE":
        return "💤";
      case "ACTIVE_CONVO_CONTINUE_SEQUENCE":
        return "";
      default:
        return "";
    }
  };

  const filteredFrameworkData =
    openedOutboundChannel === "LINKEDIN"
      ? bumpFrameworks.length > 0
        ? bumpFrameworks
            .sort((a: BumpFramework, b: BumpFramework) => {
              return a.title.localeCompare(b.title);
            })
            .filter((i) => {
              if (
                !replyLabel &&
                replyLabel !== "ACTIVE_CONVO_CONTINUE_SEQUENCE"
              ) {
                return i;
              }

              if (replyLabel === "ACTIVE_CONVO_CONTINUE_SEQUENCE") {
                return (
                  i.overall_status === "ACCEPTED" ||
                  i.overall_status === "BUMPED"
                );
              }

              return i.substatus === replyLabel;
            })
            .map((bf: BumpFramework) => {
              let title = bf.title;
              if (
                bf.overall_status === "ACCEPTED" ||
                bf.overall_status === "BUMPED"
              ) {
                title =
                  "(step #" +
                  (bf.bumped_count ? bf.bumped_count + 1 : 1) +
                  ") " +
                  bf.title;
              }

              return {
                value: bf.id + "",
                label: title,
              };
            })
        : []
      : emailReplyFrameworks?.length > 0
      ? emailReplyFrameworks
          .sort((a: EmailReplyFramework, b: EmailReplyFramework) => {
            return a.title.localeCompare(b.title);
          })
          .filter((i) => {
            if (!replyLabel) {
              return i;
            }
            return i.substatus === replyLabel;
          })
          .map((step: EmailReplyFramework) => {
            return {
              value: step.id + "",
              // label: (step.default ? "🟢 " : "⚪️ ") + step.title,
              label: step.title,
            };
          })
      : [];

  return (
    <Paper
      shadow="sm"
      withBorder
      radius={theme.radius.md}
      sx={{
        display: "flex",
        flexDirection: "column",
        flexWrap: "nowrap",
        position: "relative",
      }}
      style={{ border: '0px' }}
      pb={8}
      mah={500}
      // bg={'transparent'}
    >
      <LoadingOverlay visible={msgLoading} />
      <div key={openedProspectId} className='mb-4 bg-transparent mx-6'>
        <ScheduledMessage ref={scheduledMessageRef} openedProspectId={openedProspectId}/>
      </div>
      <div
        style={{
          flexBasis: "15%",
          backgroundColor: "#25262b",
          borderTopLeftRadius: theme.radius.md,
          borderTopRightRadius: theme.radius.md,
        }}
      >
        <Group spacing={0} position="apart">
          <Flex wrap="nowrap" align="center">
            <Text color="white" fz={14} fw={500} pl={15} pt={5}>
              {openedOutboundChannel === "LINKEDIN"
                ? "Message via LinkedIn"
                : "Reply via Email"}
            </Text>
            <Text
              pl={10}
              pt={5}
              size="xs"
              fs="italic"
              color="gray.3"
              component="a"
              target="_blank"
              rel="noopener noreferrer"
              href={
                openedOutboundChannel === "LINKEDIN"
                  ? `https://www.linkedin.com/in/${props.linkedin_public_id}`
                  : `mailto:${props.email}`
              }
            >
              {openedOutboundChannel === "LINKEDIN"
                ? `linkedin.com/in/${_.truncate(props.linkedin_public_id, {
                    length: 20,
                  })}`
                : props.email}{" "}
              <IconExternalLink size="0.65rem" />
            </Text>
          </Flex>
          <Flex>
            {/* {openedOutboundChannel !== "LINKEDIN" && (
            <Button 
              variant="transparent" 
              style={{ color: "white" }} 
              onClick={() => setShowCc(!showCc)}
            >
              CC
              {ccEmails.length > 0 && (
                <Badge color="blue" variant="filled" style={{ marginLeft: '8px' }}>
                  {ccEmails.length}
                </Badge>
              )}
            </Button>
          )}
          {openedOutboundChannel !== "LINKEDIN" && (
            <Button 
              variant="transparent" 
              style={{ color: "white" }} 
              onClick={() => setShowBcc(!showBcc)}
            >
              BCC
              {bccEmails.length > 0 && (
                <Badge color="blue" variant="filled" style={{ marginLeft: '8px' }}>
                  {bccEmails.length}
                </Badge>
              )}
            </Button>
          )} */}
            {true && ( // TODO: Added chat box expanding
              <div style={{ paddingRight: 5 }}>
                <ActionIcon
                  color="gray.0"
                  size="lg"
                  variant="transparent"
                  onClick={props.minimizedSendBox}
                >
                  <IconChevronDown size="1rem" />
                </ActionIcon>
              </div>
            )}
          </Flex>
        </Group>
      </div>
      <div
        style={{
          flexBasis: "85%",
          position: "relative",
          paddingLeft: 10,
          paddingRight: 10,
        }}
      >
        {openedOutboundChannel === "EMAIL" && (
          <Flex mt={"xs"} justify={"space-between"} gap={"md"} align={"center"}>
            <Flex
              w={"100%"}
              h={36}
              style={{ border: "1px solid #ced4da", borderRadius: "5px" }}
              align={"center"}
            >
              <span
                style={{
                  borderRadius: "4px",
                  color: "#7A8595",
                  padding: "1px 16px",
                  fontSize: "14px",
                }}
              >
                From:
              </span>
              <Flex w={"100%"} my={7} mx={4}>
                <div className="bg-[#ECEEF1] px-2 py-[3px] rounded-md text-[14px]">
                  {props.email}
                </div>
              </Flex>
              {/* <Flex h={"100%"} px={4} sx={{ borderLeft: "1px solid #ced4da" }}>
              <ActionIcon className="m-auto ">
                <IconAdjustmentsHorizontal color="gray" />
              </ActionIcon>
            </Flex> */}
            </Flex>
            <Button.Group>
              <Button
                variant="default"
                bg={showCc ? "#F7F8FA" : ""}
                onClick={() => setShowCc(!showCc)}
                className={`${showCc ? "text-[#7A8595] !important" : ""}`}
              >
                CC
                {ccEmails.length > 0 && (
                  <Badge
                    color="blue"
                    variant="filled"
                    style={{ marginLeft: "8px" }}
                  >
                    {ccEmails.length}
                  </Badge>
                )}
              </Button>
              <Button
                variant="default"
                bg={showBcc ? "#F7F8FA" : ""}
                onClick={() => setShowBcc(!showBcc)}
                className={`${showBcc ? "text-[#7A8595] !important" : ""}`}
              >
                BCC
                {bccEmails.length > 0 && (
                  <Badge
                    color="blue"
                    variant="filled"
                    style={{ marginLeft: "8px" }}
                  >
                    {bccEmails.length}
                  </Badge>
                )}
              </Button>
            </Button.Group>
          </Flex>
        )}

        {openedOutboundChannel === "EMAIL" && (
          <Flex direction={"column"} mt={"xs"}>
            {showCc && (
              <div style={{ position: "relative", marginBottom: "10px" }}>
                <span
                  style={{
                    position: "absolute",
                    left: "14px",
                    top: "7px",
                    borderRadius: "4px",
                    zIndex: 10,
                    fontSize: "14px",
                    color: "#7A8595",
                    // backgroundColor: '#1a252f',
                    padding: "1px 3px",
                  }}
                >
                  CC:
                </span>
                <MultiSelect
                  data={ccEmails}
                  value={ccEmails}
                  onChange={setCcEmails}
                  creatable
                  getCreateLabel={(query) => `+ Add ${query}`}
                  searchable
                  searchValue={ccInputValue} // Controlled input value
                  onSearchChange={setCcInputValue} // Update input value on change
                  styles={{
                    rightSection: { display: "none" }, // Hide the dropdown arrow
                    input: { paddingLeft: "60px" }, // Adjust padding to prevent text overlap
                    values: {
                      marginLeft: "10px",
                    },
                  }}
                  onKeyDown={(event) => {
                    if (event.key === "Enter") {
                      const inputValue = event.currentTarget.value;
                      if (isValidEmail(inputValue)) {
                        setCcEmails((current) => [...current, inputValue]);
                        setCcInputValue(""); // Clear the controlled input value
                        event.preventDefault();
                      }
                    }
                  }}
                />
              </div>
            )}
            {showBcc && (
              <div style={{ position: "relative", marginBottom: "10px" }}>
                <span
                  style={{
                    position: "absolute",
                    left: "14px",
                    top: "7px",
                    marginRight: "10px",
                    borderRadius: "4px",
                    zIndex: 10,
                    color: "#7A8595",
                    // backgroundColor: '#1a252f',
                    padding: "1px 3px",
                  }}
                >
                  BCC:
                </span>
                <MultiSelect
                  data={bccEmails}
                  value={bccEmails}
                  onChange={setBccEmails}
                  creatable
                  getCreateLabel={(query) => `+ Add ${query}`}
                  searchable
                  searchValue={bccInputValue} // Controlled input value
                  onSearchChange={setBccInputValue} // Update input value on change
                  styles={{
                    rightSection: { display: "none" }, // Hide the dropdown arrow
                    input: { paddingLeft: "60px" }, // Adjust padding to prevent text overlap
                    values: {
                      marginLeft: "10px",
                    },
                  }}
                  onKeyDown={(event) => {
                    if (event.key === "Enter") {
                      const inputValue = event.currentTarget.value;
                      if (isValidEmail(inputValue)) {
                        setBccEmails((current) => [...current, inputValue]);
                        setBccInputValue(""); // Clear the controlled input value
                        event.preventDefault();
                      }
                    }
                  }}
                />
              </div>
            )}
          </Flex>
        )}

        <Flex justify={"space-between"} mt={10} gap={"xs"}>
          {/* <Flex align={"center"} gap={"xs"} w="35%">
            <Text fw={700} fz={"10px"} color="gray.6" w="35%">
              Reply Label
            </Text>
            <Select
              w="65%"
              size="xs"
              onChange={(val) => {
                setReplyLabel(val || "");
                setBumpFramework(
                  bumpFrameworks.find((bf) => bf.substatus === val) ||
                    bumpFrameworks[0]
                );

                updateChannelStatus(
                  openedProspectId,
                  userToken,
                  "LINKEDIN",
                  val || "",
                  false,
                  true
                ).then((res) => {
                  showNotification({
                    id: "update-channel-status",
                    title: "Status updated",
                    message: "",
                    color: "green",
                    autoClose: 3000,
                  });

                  queryClient.refetchQueries({
                    queryKey: [
                      `query-get-dashboard-prospect-${openedProspectId}`,
                    ],
                  });
                });
              }}
              value={replyLabel}
              withinPortal
              data={replyLabels
                .filter((label) => label)
                .map((label) => ({
                  value: label,
                  label:
                    labelEmoji(label) +
                    " " +
                    convertToTitleCase(
                      label
                        ?.replaceAll("ACTIVE_CONVO_", "")
                        .replaceAll("_", " ")
                        .toLowerCase()
                    ),
                }))}
            />
          </Flex> */}
          <Flex gap={"xs"} align={"center"} justify={"space-between"}>
            {/* only show for linkedin */}
            <Flex gap={4} align={"center"}>
              <IconSparkles size={"0.9rem"} />
              <Flex w={"100%"}>
                <Text fw={700} fz={"10px"} color="gray.6" w={"100%"}>
                  AI Response
                </Text>
              </Flex>
            </Flex>
            <Select
              w={200}
              size="xs"
              onChange={(val) => {
                setReplyLabel(val || "");
                setBumpFramework(
                  bumpFrameworks.find((bf) => bf.substatus === val) ||
                    bumpFrameworks[0]
                );

                updateChannelStatus(
                  openedProspectId,
                  userToken,
                  "LINKEDIN",
                  val || "",
                  false,
                  true
                ).then((res) => {
                  showNotification({
                    id: "update-channel-status",
                    title: "Status updated",
                    message: "",
                    color: "green",
                    autoClose: 3000,
                  });

                  queryClient.refetchQueries({
                    queryKey: [
                      `query-get-dashboard-prospect-${openedProspectId}`,
                    ],
                  });
                });
              }}
              value={replyLabel}
              withinPortal
              data={replyLabels
                .filter((label) => label)
                .map((label) => ({
                  value: label,
                  label:
                    labelEmoji(label) +
                    " " +
                    convertToTitleCase(
                      label
                        ?.replaceAll("ACTIVE_CONVO_", "")
                        .replaceAll("_", " ")
                        .toLowerCase()
                    ),
                }))}
            />
            {/* <Flex align={"center"} pos={"relative"} w="75%">
              <Select
                rightSection={
                  <Tooltip
                    label={selectedBumpFramework ? `Manage '${selectedBumpFramework.title}'` : `Configure Msg Gen`}
                    withArrow
                    disabled={openedOutboundChannel != "LINKEDIN"}
                  >
                    <Button
                      variant="outline"
                      color="gray.8"
                      size="xs"
                      w={"100%"}
                      radius={0}
                      sx={(theme) => ({
                        border: "none",
                        borderLeft: `1px solid ${theme.colors.gray[4]}`,
                        paddingLeft: 4,
                        paddingRight: 4,
                      })}
                      onClick={() => {
                        setOpenBumpFrameworks(true);
                      }}
                      disabled={openedOutboundChannel != "LINKEDIN"}
                    >
                      {selectedBumpFramework ? <IconSettingsFilled size="0.8rem" /> : <IconSettings size="0.8rem" />}
                    </Button>
                  </Tooltip>
                }
                withinPortal
                placeholder={filteredFrameworkData.length > 0 ? "Select Framework" : "No Frameworks"}
                size="xs"
                disabled={filteredFrameworkData.length === 0}
                defaultValue={filteredFrameworkData.length > 0 ? filteredFrameworkData[0] + "" : undefined}
                data={filteredFrameworkData}
                // styles={{
                //   input: {
                //     borderColor: "black",
                //     borderRight: "0",
                //     borderLeft: "0",
                //   },
                //   dropdown: { minWidth: 250 },
                // }}
                onChange={(value) => {
                  if (openedOutboundChannel === "LINKEDIN") {
                    const selected = bumpFrameworks.find((bf) => bf.id === parseInt(value as string));
                    if (selected) {
                      setBumpFramework(selected);
                      if (selected.substatus) {
                        setReplyLabel(selected.substatus);
                      }
                    }

                    const substatus = bumpFrameworks.length > 0 ? bumpFrameworks[0].substatus : undefined;
                    setSetOpenBumpFrameworksSubstatus(substatus);
                  } else if (openedOutboundChannel === "EMAIL" || openedOutboundChannel === "SMARTLEAD") {
                    const selected = emailReplyFrameworks.find((step) => step.id === parseInt(value as string));
                    if (selected) {
                      setEmailReplyFramework(selected);
                    }
                  }
                }}
                value={openedOutboundChannel === "LINKEDIN" ? selectedBumpFramework?.id + "" : selectedEmailReplyFramework?.id + ""}
              />
            </Flex> */}

            <Button
              leftIcon={<IconPencil size="1rem" />}
              variant="outline"
              sx={{
                "&[data-disabled]": {
                  backgroundColor: "white",
                  border: "1px solid black",
                  pointerEvents: "all",
                },
              }}
              size="xs"
              disabled={
                (openedOutboundChannel === "LINKEDIN" &&
                  (bumpFrameworks === undefined ||
                    bumpFrameworks?.length === 0)) ||
                (openedOutboundChannel != "LINKEDIN" &&
                  (emailReplyFrameworks === undefined ||
                    emailReplyFrameworks?.length === 0))
              }
              onClick={async () => {
                setMsgLoading(true);
                if (openedOutboundChannel === "LINKEDIN") {
                  // If the substatus is breakup, then we want to generate slightly different message:
                  const result = await generateAIFollowup(
                    userToken,
                    props.prospectId,
                    selectedBumpFramework
                  );
                  setMessageDraft(result.msg);
                  setAiMessage(result.msg);
                  setAiGenerated(result.aiGenerated);
                } else if (
                  openedOutboundChannel === "EMAIL" ||
                  openedOutboundChannel === "SMARTLEAD"
                ) {
                  // if (!currentConvoEmailThread) {
                  //   showNotification({
                  //     id: "send-email-message-error",
                  //     title: "Error",
                  //     message: "Please select an email thread",
                  //     color: "red",
                  //     autoClose: false,
                  //   });
                  //   setMsgLoading(false);
                  //   return;
                  // }
                  if (!selectedEmailReplyFramework) {
                    showNotification({
                      id: "send-email-message-error",
                      title: "Error",
                      message: "Please select an email reply framework",
                      color: "red",
                      autoClose: false,
                    });
                    setMsgLoading(false);
                    return;
                  }

                  const result = await postGenerateEmailReplyUsingFramework(userToken, selectedEmailReplyFramework?.id, props.prospectId);

                  // Clean the result
                  const email_body = result.data.message;
                  if (!email_body) {
                    showNotification({
                      id: "generate-email-message-error",
                      title: "Error",
                      message: "Failed to generate message. Please try again.",
                      color: "red",
                      autoClose: false,
                    });
                    setMsgLoading(false);
                    return;
                  }
                  const message = email_body;
                  messageDraftEmail.current = message;
                  setMessageDraft(message);
                  setAiMessage(message);
                  setAiGenerated(true);
                }
                setMsgLoading(false);
              }}
            >
              Generate {openedOutboundChannel === "LINKEDIN" ? "" : "Email"}
            </Button>
          {sdrSchedulingLinks && (
            <Select
              placeholder="Select a scheduling link"
              value={null}
              data={sdrSchedulingLinks.map(link => ({ label: link.label, value: link.value }))}
              onChange={(value) => {
                if (value) {
                  const selectedLink = sdrSchedulingLinks.find(link => link.value === value);
                  const linkOwner = selectedLink ? selectedLink.label : "Unknown";
                  navigator.clipboard.writeText(value).then(() => {
                    showNotification({
                      title: "Link Copied",
                      message: `Scheduling link for ${linkOwner} has been copied to clipboard.`,
                      color: "green",
                      autoClose: 3000,
                    });
                  }).catch(() => {
                    showNotification({
                      title: "Error",
                      message: "Failed to copy the link. Please try again.",
                      color: "red",
                      autoClose: 3000,
                    });
                  });
                }
              }}
              size="xs"
              radius="md"
              icon={<IconCalendar size={"0.8rem"} />}
            />
          )}
          </Flex>
          <Popover
            width={200}
            position="bottom"
            withArrow
            shadow="md"
            styles={{
              dropdown: {
                paddingInline: "0px",
              },
            }}
          >
            <Popover.Target>
              <Button
                color="gray"
                variant="outline"
                radius={"md"}
                leftIcon={<IconCalendar size={"1rem"} />}
                rightIcon={<IconArrowsMoveVertical size={"1rem"} />}
              >
                Choose Calendar
              </Button>
            </Popover.Target>
            <Popover.Dropdown>
              <Text
                size="sm"
                className="flex gap-1 items-center"
                mb={"sm"}
                ml={"md"}
                fw={500}
                color="gray"
              >
                <IconCalendar size={"1rem"} color="gray" />
                Choose Calendar
              </Text>
              <Divider />
              <Radio.Group withAsterisk>
                <Radio
                  label={
                    <Flex align={"center"} gap={4}>
                      <Avatar size={"sm"} radius={"xl"} />
                      <Text size={"sm"} fw={500}>
                        Test User
                      </Text>
                    </Flex>
                  }
                  styles={{
                    radio: {
                      width: "18px",
                      height: "18px",
                    },
                    inner: {
                      marginTop: "3px",
                    },
                  }}
                  value="react"
                  ml={"sm"}
                  my={6}
                />
                <Divider />
                <Radio
                  value="react"
                  label={
                    <Flex align={"center"} gap={4}>
                      <Avatar size={"sm"} radius={"xl"} />
                      <Text size={"sm"} fw={500}>
                        Test User
                      </Text>
                    </Flex>
                  }
                  styles={{
                    radio: {
                      width: "18px",
                      height: "18px",
                    },
                    inner: {
                      marginTop: "3px",
                    },
                  }}
                  ml={"sm"}
                  my={6}
                />
                <Divider />
              </Radio.Group>
            </Popover.Dropdown>
          </Popover>
        </Flex>

        <Box pos={"relative"}>
          {openedOutboundChannel === "LINKEDIN" ? (
            <Textarea
              minRows={5}
              maxRows={8}
              mt="xs"
              color="gray"
              placeholder="Your message..."
              value={messageDraft}
              onChange={(event) => _setMessageDraft(event.currentTarget.value)}
              onKeyDown={getHotkeyHandler([
                [
                  "mod+Enter",
                  () => {
                    sendMessage();
                  },
                ],
              ])}
            />
          ) : (
            <Box mt="xs">
              <RichTextArea
                onChange={(value, rawValue) => {
                  messageDraftRichRaw.current = rawValue;
                  messageDraftEmail.current = value;
                }}
                value={messageDraftRichRaw.current}
                height={110}
              />
            </Box>
          )}

          {aiGenerated && (
            <AutoBumpFrameworkInfo
              useBumpFramework={selectedBumpFramework !== undefined}
              bump_title={selectedBumpFramework?.title || "None"}
              bump_description={
                selectedBumpFramework?.description || "No framework"
              }
              bump_length={selectedBumpFramework?.bump_length || "No length"}
              account_research_points={
                selectedBumpFramework?.account_research || []
              }
              bump_number_sent={selectedBumpFramework?.etl_num_times_used}
              bump_number_converted={
                selectedBumpFramework?.etl_num_times_converted
              }
            />
          )}
        </Box>

        <Flex
          align="center"
          direction="row"
          justify={"space-between"}
          wrap="wrap"
        >
          <Flex mt="xs" align="center">
            {openedOutboundChannel === "LINKEDIN" && (
              <Tooltip
                withArrow
                position="bottom"
                label="Smart Generate with AI"
              >
                <Button
                  leftIcon={<IconWand size="0.8rem" />}
                  color="grape"
                  size="xs"
                  sx={{ borderRadius: "4px 0px 0px 4px" }}
                  onClick={() => {
                    showNotification({
                      id: "generate-linkedin-message",
                      title: "Generating message ...",
                      message: "",
                      color: "blue",
                      autoClose: 3000,
                    });
                    smartGenerate("");
                  }}
                >
                  Smart Generate
                </Button>
              </Tooltip>
            )}
            <Tooltip
              label="Co-pilot a response by providing feedback"
              withArrow
              position="bottom"
            >
              <Button
                variant="outline"
                color="grape"
                size="xs"
                sx={{
                  width: "auto",
                  borderLeft: "none",
                  borderRadius: "0px 4px 4px 0px",
                }}
                onClick={() => {
                  let tempInputValue = "";
                  openConfirmModal({
                    title: "Co-pilot a response",
                    children: (
                      <Textarea
                        description="Give feedback on how to respond and a draft will be created"
                        placeholder="Describe how you want to form the generated text"
                        onChange={(event) => {
                          tempInputValue = event.currentTarget.value;
                        }}
                      />
                    ),
                    labels: {
                      confirm: "Generate with feedback",
                      cancel: "Cancel",
                    },
                    onCancel: () => {},
                    onConfirm: () => {
                      showNotification({
                        id: "generate-linkedin-message",
                        title: "Generating message ...",
                        message: "",
                        color: "blue",
                        autoClose: 3000,
                      });
                      smartGenerate(tempInputValue);
                    },
                  });
                }}
              >
                <IconMessageDots size="1rem" />
              </Button>
            </Tooltip>
          </Flex>

          <Flex mt="xs" align="center" direction="row" justify={"end"}>
            <Popover
              position="bottom"
              withArrow
              shadow="md"
              trapFocus
              opened={showCalendarPopup}
            >
              <Popover.Target>
                <Tooltip label="Set a custom snooze day" withArrow withinPortal>
                  <Flex>
                    <Button
                      onClick={() => setShowCalendarPopup((v) => !v)}
                      size="xs"
                      sx={{
                        borderTopRightRadius: 0,
                        borderBottomRightRadius: 0,
                      }}
                    >
                      <IconZzz size={"1rem"} />
                    </Button>
                  </Flex>
                </Tooltip>
              </Popover.Target>
              <Popover.Dropdown>
                <Calendar
                  placeholder={"Select a date"}
                  minDate={moment(new Date()).add(1, "days").toDate()}
                  getDayProps={(date) => ({
                    selected: moment(snoozeDay).isSame(date, "day"),
                    onClick: () => {
                      setShowCalendarPopup(false);
                      setSnoozeDay(date);
                    },
                  })}
                  onPointerEnterCapture={() => {}}
                  onPointerLeaveCapture={() => {}}
                />
              </Popover.Dropdown>
            </Popover>

            <Button
              size="xs"
              sx={{
                borderTopRightRadius: 0,
                borderBottomRightRadius: 0,
                borderTopLeftRadius: 0,
                borderBottomLeftRadius: 0,
                borderLeft: `1px solid #fff`,
                borderRight: `1px solid #fff`,
              }}
              onClick={() => sendMessage()}
              styles={(theme) => ({
                rightIcon: {
                  borderLeft: `1px solid ${theme.white}`,
                  marginLeft: "0.5rem",
                  paddingLeft: "0.25rem",
                },
              })}
            >
              {scheduleDay
                ? "Schedule for [" +
                  moment(scheduleDay).format("MMM Do h:mmA") +
                  "] "
                : "Send"}{" "}
              and Snooze for {moment(snoozeDay).diff(new Date(), "days") + 1}{" "}
              days
            </Button>
            <Popover
              position="bottom"
              withArrow
              shadow="md"
              trapFocus
              opened={showSchedulePopup}
            >
              <Popover.Target>
                <Tooltip
                  label="Schedule a send time into the future"
                  withArrow
                  withinPortal
                >
                  <Flex>
                    <Button
                      onClick={() => setShowSchedulePopup((v) => !v)}
                      size="xs"
                      sx={{ borderTopLeftRadius: 0, borderBottomLeftRadius: 0 }}
                    >
                      <IconClock24 size={"1rem"} />
                    </Button>
                  </Flex>
                </Tooltip>
              </Popover.Target>

              <Popover.Dropdown>
                <Calendar
                  placeholder={"Select a date"}
                  minDate={moment(new Date()).add(1, "days").toDate()}
                  getDayProps={(date) => ({
                    selected: moment(scheduleDay).isSame(date, "day"),
                    onClick: () => {
                      // Preserve the time
                      const hour = moment(scheduleDay).hour();
                      const minute = moment(scheduleDay).minute();
                      const newDate = moment(date)
                        .set("hour", hour)
                        .set("minute", minute)
                        .toDate();
                      setScheduleDay(newDate);
                    },
                  })}
                  onPointerEnterCapture={() => {}}
                  onPointerLeaveCapture={() => {}}
                />
                <Flex
                  mt="xs"
                  direction="row"
                  justify={"space-between"}
                  align="flex-end"
                >
                  <TimeInput
                    w="100%"
                    label="Custom Time"
                    size="sm"
                    value={moment(scheduleDay).format("HH:mm")}
                    onChange={(event) => {
                      const value = event.currentTarget.value; // Format is HH:MM
                      const hour = parseInt(value.split(":")[0]);
                      const minute = parseInt(value.split(":")[1]);
                      const newDate = moment(scheduleDay)
                        .set("hour", hour)
                        .set("minute", minute)
                        .toDate();
                      setScheduleDay(newDate);
                    }}
                  />
                  <Tooltip label="Schedule for now" withArrow withinPortal>
                    <Flex>
                      <Button
                        size="xs"
                        mb="xs"
                        ml="sm"
                        variant="transparent"
                        color="red"
                        onClick={() => {
                          setShowSchedulePopup(false);
                          setScheduleDay(undefined);
                        }}
                      >
                        <IconX size="1rem" />
                      </Button>
                    </Flex>
                  </Tooltip>
                </Flex>
              </Popover.Dropdown>
            </Popover>
          </Flex>
        </Flex>
      </div>
    </Paper>
  );
});
